{
  "instance_id": "astropy__astropy-13236",
  "run_id": "20260128_192624",
  "subset": "verified",
  "split": "test",
  "start_time": "2026-01-28T11:26:36.825485",
  "status": "success",
  "returncode": 0,
  "stdout": "           a   c\n+            --- ---\n+              1   x\n+              2   y\n+              3   z\n+\n+        This gives the same as using remove_column.\n+        '''\n+        for name in self._set_of_names_in_colnames(names):\n+            self.columns.pop(name)\n+\n+    def _convert_string_dtype(self, in_kind, out_kind, encode_decode_func):\n+        \"\"\"\n+        Convert string-like columns to/from bytestring and unicode (internal \nonly).\n+\n+        Parameters\n+        ----------\n+        in_kind : str\n+            Input dtype.kind\n+        out_kind : str\n+            Output dtype.kind\n+        \"\"\"\n+\n+        for col in self.itercols():\n+            if col.dtype.kind == in_kind:\n+                try:\n+                    # This requires ASCII and is faster by a factor of up to \n~8, so\n+                    # try that first.\n+                    newcol = col.__class__(col, dtype=out_kind)\n+                except (UnicodeEncodeError, UnicodeDecodeError):\n+                    newcol = col.__class__(encode_decode_func(col, 'utf-8'))\n+\n+                    # Quasi-manually copy info attributes.  Unfortunately\n+                    # DataInfo.__set__ does not do the right thing in this case\n+                    # so newcol.info = col.info does not get the old info \nattributes.\n+                    for attr in col.info.attr_names - col.info._attrs_no_copy -\nset(['dtype']):\n+                        value = deepcopy(getattr(col.info, attr))\n+                        setattr(newcol.info, attr, value)\n+\n+                self[col.name] = newcol\n+\n+    def convert_bytestring_to_unicode(self):\n+        \"\"\"\n+        Convert bytestring columns (dtype.kind='S') to unicode (dtype.kind='U')\n+        using UTF-8 encoding.\n+\n+        Internally this changes string columns to represent each character\n+        in the string with a 4-byte UCS-4 equivalent, so it is inefficient\n+        for memory but allows scripts to manipulate string arrays with\n+        natural syntax.\n+        \"\"\"\n+        self._convert_string_dtype('S', 'U', np.char.decode)\n+\n+    def convert_unicode_to_bytestring(self):\n+        \"\"\"\n+        Convert unicode columns (dtype.kind='U') to bytestring (dtype.kind='S')\n+        using UTF-8 encoding.\n+\n+        When exporting a unicode string array to a file, it may be desirable\n+        to encode unicode columns as bytestrings.\n+        \"\"\"\n+        self._convert_string_dtype('U', 'S', np.char.encode)\n+\n+    def keep_columns(self, names):\n+        '''\n+        Keep only the columns specified (remove the others).\n+\n+        Parameters\n+        ----------\n+        names : str or iterable of str\n+            The columns to keep. All other columns will be removed.\n+\n+        Examples\n+        --------\n+        Create a table with three columns 'a', 'b' and 'c'::\n+\n+            >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],\n+            ...           names=('a', 'b', 'c'))\n+            >>> print(t)\n+             a   b   c\n+            --- --- ---\n+              1 0.1   x\n+              2 0.2   y\n+              3 0.3   z\n+\n+        Keep only column 'a' of the table::\n+\n+            >>> t.keep_columns('a')\n+            >>> print(t)\n+             a\n+            ---\n+              1\n+              2\n+              3\n+\n+        Keep columns 'a' and 'c' of the table::\n+\n+            >>> t = Table([[1, 2, 3],[0.1, 0.2, 0.3],['x', 'y', 'z']],\n+            ...           names=('a', 'b', 'c'))\n+            >>> t.keep_columns(['a', 'c'])\n+            >>> print(t)\n+             a   c\n+            --- ---\n+              1   x\n+              2   y\n+              3   z\n+        '''\n+        names = self._set_of_names_in_colnames(names)\n+        for colname in self.colnames:\n+            if colname not in names:\n+                self.columns.pop(colname)\n+\n+    def rename_column(self, name, new_name):\n+        '''\n+        Rename a column.\n+\n+        This can also be done directly with by setting the ``name`` attribute\n+        for a column::\n+\n+          table[name].name = new_name\n+\n+        TODO: this won't work for mixins\n+\n+        Parameters\n+        ----------\n+        name : str\n+            The current name of the column.\n+        new_name : str\n+            The new name for the column\n+\n+        Examples\n+        --------\n+        Create a table with three columns 'a', 'b' and 'c'::\n+\n+            >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))\n+            >>> print(t)\n+             a   b   c\n+            --- --- ---\n+              1   3   5\n+              2   4   6\n+\n+        Renaming column 'a' to 'aa'::\n+\n+            >>> t.rename_column('a' , 'aa')\n+            >>> print(t)\n+             aa  b   c\n+            --- --- ---\n+              1   3   5\n+              2   4   6\n+        '''\n+\n+        if name not in self.keys():\n+            raise KeyError(f\"Column {name} does not exist\")\n+\n+        self.columns[name].info.name = new_name\n+\n+    def rename_columns(self, names, new_names):\n+        '''\n+        Rename multiple columns.\n+\n+        Parameters\n+        ----------\n+        names : list, tuple\n+            A list or tuple of existing column names.\n+        new_names : list, tuple\n+            A list or tuple of new column names.\n+\n+        Examples\n+        --------\n+        Create a table with three columns 'a', 'b', 'c'::\n+\n+            >>> t = Table([[1,2],[3,4],[5,6]], names=('a','b','c'))\n+            >>> print(t)\n+              a   b   c\n+             --- --- ---\n+              1   3   5\n+              2   4   6\n+\n+        Renaming columns 'a' to 'aa' and 'b' to 'bb'::\n+\n+            >>> names = ('a','b')\n+            >>> new_names = ('aa','bb')\n+            >>> t.rename_columns(names, new_names)\n+            >>> print(t)\n+             aa  bb   c\n+            --- --- ---\n+              1   3   5\n+              2   4   6\n+        '''\n+\n+        if not self._is_list_or_tuple_of_str(names):\n+            raise TypeError(\"input 'names' must be a tuple or a list of column \nnames\")\n+\n+        if not self._is_list_or_tuple_of_str(new_names):\n+            raise TypeError(\"input 'new_names' must be a tuple or a list of \ncolumn names\")\n+\n+        if len(names) != len(new_names):\n+            raise ValueError(\"input 'names' and 'new_names' list arguments must\nbe the same length\")\n+\n+        for name, new_name in zip(names, new_names):\n+            self.rename_column(name, new_name)\n+\n+    def _set_row(self, idx, colnames, vals):\n+        try:\n+            assert len(vals) == len(colnames)\n+        except Exception:\n+            raise ValueError('right hand side must be a sequence of values with\n'\n+                             'the same length as the number of selected \ncolumns')\n+\n+        # Keep track of original values before setting each column so that\n+        # setting row can be transactional.\n+        orig_vals = []\n+        cols = self.columns\n+        try:\n+            for name, val in zip(colnames, vals):\n+                orig_vals.append(cols[name][idx])\n+                cols[name][idx] = val\n+        except Exception:\n+            # If anything went wrong first revert the row update then raise\n+            for name, val in zip(colnames, orig_vals[:-1]):\n+                cols[name][idx] = val\n+            raise\n+\n+    def add_row(self, vals=None, mask=None):\n+        \"\"\"Add a new row to the end of the table.\n+\n+        The ``vals`` argument can be:\n+\n+        sequence (e.g. tuple or list)\n+            Column values in the same order as table columns.\n+        mapping (e.g. dict)\n+            Keys corresponding to column names.  Missing values will be\n+            filled with np.zeros for the column dtype.\n+        `None`\n+            All values filled with np.zeros for the column dtype.\n+\n+        This method requires that the Table object \"owns\" the underlying array\n+        data.  In particular one cannot add a row to a Table that was\n+        initialized with copy=False from an existing array.\n+\n+        The ``mask`` attribute should give (if desired) the mask for the\n+        values. The type of the mask should match that of the values, i.e. if\n+        ``vals`` is an iterable, then ``mask`` should also be an iterable\n+        with the same length, and if ``vals`` is a mapping, then ``mask``\n+        should be a dictionary.\n+\n+        Parameters\n+        ----------\n+        vals : tuple, list, dict or None\n+            Use the specified values in the new row\n+        mask : tuple, list, dict or None\n+            Use the specified mask values in the new row\n+\n+        Examples\n+        --------\n+        Create a table with three columns 'a', 'b' and 'c'::\n+\n+           >>> t = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))\n+           >>> print(t)\n+            a   b   c\n+           --- --- ---\n+             1   4   7\n+             2   5   8\n+\n+        Adding a new row with entries '3' in 'a', '6' in 'b' and '9' in 'c'::\n+\n+           >>> t.add_row([3,6,9])\n+           >>> print(t)\n+             a   b   c\n+             --- --- ---\n+             1   4   7\n+             2   5   8\n+             3   6   9\n+        \"\"\"\n+        self.insert_row(len(self), vals, mask)\n+\n+    def insert_row(self, index, vals=None, mask=None):\n+        \"\"\"Add a new row before the given ``index`` position in the table.\n+\n+        The ``vals`` argument can be:\n+\n+        sequence (e.g. tuple or list)\n+            Column values in the same order as table columns.\n+        mapping (e.g. dict)\n+            Keys corresponding to column names.  Missing values will be\n+            filled with np.zeros for the column dtype.\n+        `None`\n+            All values filled with np.zeros for the column dtype.\n+\n+        The ``mask`` attribute should give (if desired) the mask for the\n+        values. The type of the mask should match that of the values, i.e. if\n+        ``vals`` is an iterable, then ``mask`` should also be an iterable\n+        with the same length, and if ``vals`` is a mapping, then ``mask``\n+        should be a dictionary.\n+\n+        Parameters\n+        ----------\n+        vals : tuple, list, dict or None\n+            Use the specified values in the new row\n+        mask : tuple, list, dict or None\n+            Use the specified mask values in the new row\n+        \"\"\"\n+        colnames = self.colnames\n+\n+        N = len(self)\n+        if index < -N or index > N:\n+            raise IndexError(\"Index {} is out of bounds for table with length \n{}\"\n+                             .format(index, N))\n+        if index < 0:\n+            index += N\n+\n+        if isinstance(vals, Mapping) or vals is None:\n+            # From the vals and/or mask mappings create the corresponding lists\n+            # that have entries for each table column.\n+            if mask is not None and not isinstance(mask, Mapping):\n+                raise TypeError(\"Mismatch between type of vals and mask\")\n+\n+            # Now check that the mask is specified for the same keys as the\n+            # values, otherwise things get really confusing.\n+            if mask is not None and set(vals.keys()) != set(mask.keys()):\n+                raise ValueError('keys in mask should match keys in vals')\n+\n+            if vals and any(name not in colnames for name in vals):\n+                raise ValueError('Keys in vals must all be valid column names')\n+\n+            vals_list = []\n+            mask_list = []\n+\n+            for name in colnames:\n+                if vals and name in vals:\n+                    vals_list.append(vals[name])\n+                    mask_list.append(False if mask is None else mask[name])\n+                else:\n+                    col = self[name]\n+                    if hasattr(col, 'dtype'):\n+                        # Make a placeholder zero element of the right type \nwhich is masked.\n+                        # This assumes the appropriate insert() method will \nbroadcast a\n+                        # numpy scalar to the right shape.\n+                        vals_list.append(np.zeros(shape=(), dtype=col.dtype))\n+\n+                        # For masked table any unsupplied values are masked by \ndefault.\n+                        mask_list.append(self.masked and vals is not None)\n+                    else:\n+                        raise ValueError(f\"Value must be supplied for column \n'{name}'\")\n+\n+            vals = vals_list\n+            mask = mask_list\n+\n+        if isiterable(vals):\n+            if mask is not None and (not isiterable(mask) or isinstance(mask, \nMapping)):\n+                raise TypeError(\"Mismatch between type of vals and mask\")\n+\n+            if len(self.columns) != len(vals):\n+                raise ValueError('Mismatch between number of vals and columns')\n+\n+            if mask is not None:\n+                if len(self.columns) != len(mask):\n+                    raise ValueError('Mismatch between number of masks and \ncolumns')\n+            else:\n+                mask = [False] * len(self.columns)\n+\n+        else:\n+            raise TypeError('Vals must be an iterable or mapping or None')\n+\n+        # Insert val at index for each column\n+        columns = self.TableColumns()\n+        for name, col, val, mask_ in zip(colnames, self.columns.values(), vals,\nmask):\n+            try:\n+                # If new val is masked and the existing column does not support\nmasking\n+                # then upgrade the column to a mask-enabled type: either the \ntable-level\n+                # default ColumnClass or else MaskedColumn.\n+                if mask_ and isinstance(col, Column) and not isinstance(col, \nMaskedColumn):\n+                    col_cls = (self.ColumnClass\n+                               if issubclass(self.ColumnClass, \nself.MaskedColumn)\n+                               else self.MaskedColumn)\n+                    col = col_cls(col, copy=False)\n+\n+                newcol = col.insert(index, val, axis=0)\n+\n+                if len(newcol) != N + 1:\n+                    raise ValueError('Incorrect length for column {} after \ninserting {}'\n+                                     ' (expected {}, got {})'\n+                                     .format(name, val, len(newcol), N + 1))\n+                newcol.info.parent_table = self\n+\n+                # Set mask if needed and possible\n+                if mask_:\n+                    if hasattr(newcol, 'mask'):\n+                        newcol[index] = np.ma.masked\n+                    else:\n+                        raise TypeError(\"mask was supplied for column '{}' but \nit does not \"\n+                                        \"support masked \nvalues\".format(col.info.name))\n+\n+                columns[name] = newcol\n+\n+            except Exception as err:\n+                raise ValueError(\"Unable to insert row because of exception in \ncolumn '{}':\\n{}\"\n+                                 .format(name, err)) from err\n+\n+        for table_index in self.indices:\n+            table_index.insert_row(index, vals, self.columns.values())\n+\n+        self._replace_cols(columns)\n+\n+        # Revert groups to default (ungrouped) state\n+        if hasattr(self, '_groups'):\n+            del self._groups\n+\n+    def _replace_cols(self, columns):\n+        for col, new_col in zip(self.columns.values(), columns.values()):\n+            new_col.info.indices = []\n+            for index in col.info.indices:\n+                index.columns[index.col_position(col.info.name)] = new_col\n+                new_col.info.indices.append(index)\n+\n+        self.columns = columns\n+\n+    def update(self, other, copy=True):\n+        \"\"\"\n+        Perform a dictionary-style update and merge metadata.\n+\n+        The argument ``other`` must be a |Table|, or something that can be used\n+        to initialize a table. Columns from (possibly converted) ``other`` are\n+        added to this table. In case of matching column names the column from\n+        this table is replaced with the one from ``other``.\n+\n+        Parameters\n+        ----------\n+        other : table-like\n+            Data to update this table with.\n+        copy : bool\n+            Whether the updated columns should be copies of or references to\n+            the originals.\n+\n+        See Also\n+        --------\n+        add_columns, astropy.table.hstack, replace_column\n+\n+        Examples\n+        --------\n+        Update a table with another table::\n+\n+            >>> t1 = Table({'a': ['foo', 'bar'], 'b': [0., 0.]}, meta={'i': 0})\n+            >>> t2 = Table({'b': [1., 2.], 'c': [7., 11.]}, meta={'n': 2})\n+            >>> t1.update(t2)\n+            >>> t1\n+            <Table length=2>\n+             a      b       c\n+            str3 float64 float64\n+            ---- ------- -------\n+             foo     1.0     7.0\n+             bar     2.0    11.0\n+            >>> t1.meta\n+            {'i': 0, 'n': 2}\n+\n+        Update a table with a dictionary::\n+\n+            >>> t = Table({'a': ['foo', 'bar'], 'b': [0., 0.]})\n+            >>> t.update({'b': [1., 2.]})\n+            >>> t\n+            <Table length=2>\n+             a      b\n+            str3 float64\n+            ---- -------\n+             foo     1.0\n+             bar     2.0\n+        \"\"\"\n+        from .operations import _merge_table_meta\n+        if not isinstance(other, Table):\n+            other = self.__class__(other, copy=copy)\n+        common_cols = set(self.colnames).intersection(other.colnames)\n+        for name, col in other.items():\n+            if name in common_cols:\n+                self.replace_column(name, col, copy=copy)\n+            else:\n+                self.add_column(col, name=name, copy=copy)\n+        _merge_table_meta(self, [self, other], metadata_conflicts='silent')\n+\n+    def argsort(self, keys=None, kind=None, reverse=False):\n+        \"\"\"\n+        Return the indices which would sort the table according to one or\n+        more key columns.  This simply calls the `numpy.argsort` function on\n+        the table with the ``order`` parameter set to ``keys``.\n+\n+        Parameters\n+        ----------\n+        keys : str or list of str\n+            The column name(s) to order the table by\n+        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n+            Sorting algorithm used by ``numpy.argsort``.\n+        reverse : bool\n+            Sort in reverse order (default=False)\n+\n+        Returns\n+        -------\n+        index_array : ndarray, int\n+            Array of indices that sorts the table by the specified key\n+            column(s).\n+        \"\"\"\n+        if isinstance(keys, str):\n+            keys = [keys]\n+\n+        # use index sorted order if possible\n+        if keys is not None:\n+            index = get_index(self, names=keys)\n+            if index is not None:\n+                idx = np.asarray(index.sorted_data())\n+                return idx[::-1] if reverse else idx\n+\n+        kwargs = {}\n+        if keys:\n+            # For multiple keys return a structured array which gets sorted,\n+            # while for a single key return a single ndarray.  Sorting a\n+            # one-column structured array is slower than ndarray (e.g. a\n+            # factor of ~6 for a 10 million long random array), and much slower\n+            # for in principle sortable columns like Time, which get stored as\n+            # object arrays.\n+            if len(keys) > 1:\n+                kwargs['order'] = keys\n+                data = self.as_array(names=keys)\n+            else:\n+                data = self[keys[0]]\n+        else:\n+            # No keys provided so sort on all columns.\n+            data = self.as_array()\n+\n+        if kind:\n+            kwargs['kind'] = kind\n+\n+        # np.argsort will look for a possible .argsort method (e.g., for Time),\n+        # and if that fails cast to an array and try sorting that way.\n+        idx = np.argsort(data, **kwargs)\n+\n+        return idx[::-1] if reverse else idx\n+\n+    def sort(self, keys=None, *, kind=None, reverse=False):\n+        '''\n+        Sort the table according to one or more keys. This operates\n+        on the existing table and does not return a new table.\n+\n+        Parameters\n+        ----------\n+        keys : str or list of str\n+            The key(s) to order the table by. If None, use the\n+            primary index of the Table.\n+        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n+            Sorting algorithm used by ``numpy.argsort``.\n+        reverse : bool\n+            Sort in reverse order (default=False)\n+\n+        Examples\n+        --------\n+        Create a table with 3 columns::\n+\n+            >>> t = Table([['Max', 'Jo', 'John'], ['Miller', 'Miller', \n'Jackson'],\n+            ...            [12, 15, 18]], names=('firstname', 'name', 'tel'))\n+            >>> print(t)\n+            firstname   name  tel\n+            --------- ------- ---\n+                  Max  Miller  12\n+                   Jo  Miller  15\n+                 John Jackson  18\n+\n+        Sorting according to standard sorting rules, first 'name' then \n'firstname'::\n+\n+            >>> t.sort(['name', 'firstname'])\n+            >>> print(t)\n+            firstname   name  tel\n+            --------- ------- ---\n+                 John Jackson  18\n+                   Jo  Miller  15\n+                  Max  Miller  12\n+\n+        Sorting according to standard sorting rules, first 'firstname' then \n'tel',\n+        in reverse order::\n+\n+            >>> t.sort(['firstname', 'tel'], reverse=True)\n+            >>> print(t)\n+            firstname   name  tel\n+            --------- ------- ---\n+                  Max  Miller  12\n+                 John Jackson  18\n+                   Jo  Miller  15\n+        '''\n+        if keys is None:\n+            if not self.indices:\n+                raise ValueError(\"Table sort requires input keys or a table \nindex\")\n+            keys = [x.info.name for x in self.indices[0].columns]\n+\n+        if isinstance(keys, str):\n+            keys = [keys]\n+\n+        indexes = self.argsort(keys, kind=kind, reverse=reverse)\n+\n+        with self.index_mode('freeze'):\n+            for name, col in self.columns.items():\n+                # Make a new sorted column.  This requires that take() also \ncopies\n+                # relevant info attributes for mixin columns.\n+                new_col = col.take(indexes, axis=0)\n+\n+                # First statement in try: will succeed if the column supports \nan in-place\n+                # update, and matches the legacy behavior of astropy Table.  \nHowever,\n+                # some mixin classes may not support this, so in that case just\ndrop\n+                # in the entire new column. See #9553 and #9536 for discussion.\n+                try:\n+                    col[:] = new_col\n+                except Exception:\n+                    # In-place update failed for some reason, exception class \nnot\n+                    # predictable for arbitrary mixin.\n+                    self[col.info.name] = new_col\n+\n+    def reverse(self):\n+        '''\n+        Reverse the row order of table rows.  The table is reversed\n+        in place and there are no function arguments.\n+\n+        Examples\n+        --------\n+        Create a table with three columns::\n+\n+            >>> t = Table([['Max', 'Jo', 'John'], \n['Miller','Miller','Jackson'],\n+            ...         [12,15,18]], names=('firstname','name','tel'))\n+            >>> print(t)\n+            firstname   name  tel\n+            --------- ------- ---\n+                  Max  Miller  12\n+                   Jo  Miller  15\n+                 John Jackson  18\n+\n+        Reversing order::\n+\n+            >>> t.reverse()\n+            >>> print(t)\n+            firstname   name  tel\n+            --------- ------- ---\n+                 John Jackson  18\n+                   Jo  Miller  15\n+                  Max  Miller  12\n+        '''\n+        for col in self.columns.values():\n+            # First statement in try: will succeed if the column supports an \nin-place\n+            # update, and matches the legacy behavior of astropy Table.  \nHowever,\n+            # some mixin classes may not support this, so in that case just \ndrop\n+            # in the entire new column. See #9836, #9553, and #9536 for \ndiscussion.\n+            new_col = col[::-1]\n+            try:\n+                col[:] = new_col\n+            except Exception:\n+                # In-place update failed for some reason, exception class not\n+                # predictable for arbitrary mixin.\n+                self[col.info.name] = new_col\n+\n+        for index in self.indices:\n+            index.reverse()\n+\n+    def round(self, decimals=0):\n+        '''\n+        Round numeric columns in-place to the specified number of decimals.\n+        Non-numeric columns will be ignored.\n+\n+        Examples\n+        --------\n+        Create three columns with different types:\n+\n+            >>> t = Table([[1, 4, 5], [-25.55, 12.123, 85],\n+            ...     ['a', 'b', 'c']], names=('a', 'b', 'c'))\n+            >>> print(t)\n+             a    b     c\n+            --- ------ ---\n+              1 -25.55   a\n+              4 12.123   b\n+              5   85.0   c\n+\n+        Round them all to 0:\n+\n+            >>> t.round(0)\n+            >>> print(t)\n+             a    b    c\n+            --- ----- ---\n+              1 -26.0   a\n+              4  12.0   b\n+              5  85.0   c\n+\n+        Round column 'a' to -1 decimal:\n+\n+            >>> t.round({'a':-1})\n+            >>> print(t)\n+             a    b    c\n+            --- ----- ---\n+              0 -26.0   a\n+              0  12.0   b\n+              0  85.0   c\n+\n+        Parameters\n+        ----------\n+        decimals: int, dict\n+            Number of decimals to round the columns to. If a dict is given,\n+            the columns will be rounded to the number specified as the value.\n+            If a certain column is not in the dict given, it will remain the\n+            same.\n+        '''\n+        if isinstance(decimals, Mapping):\n+            decimal_values = decimals.values()\n+            column_names = decimals.keys()\n+        elif isinstance(decimals, int):\n+            decimal_values = itertools.repeat(decimals)\n+            column_names = self.colnames\n+        else:\n+            raise ValueError(\"'decimals' argument must be an int or a dict\")\n+\n+        for colname, decimal in zip(column_names, decimal_values):\n+            col = self.columns[colname]\n+            if np.issubdtype(col.info.dtype, np.number):\n+                try:\n+                    np.around(col, decimals=decimal, out=col)\n+                except TypeError:\n+                    # Bug in numpy see \nhttps://github.com/numpy/numpy/issues/15438\n+                    col[()] = np.around(col, decimals=decimal)\n+\n+    def copy(self, copy_data=True):\n+        '''\n+        Return a copy of the table.\n+\n+        Parameters\n+        ----------\n+        copy_data : bool\n+            If `True` (the default), copy the underlying data array.\n+            Otherwise, use the same data array. The ``meta`` is always\n+            deepcopied regardless of the value for ``copy_data``.\n+        '''\n+        out = self.__class__(self, copy=copy_data)\n+\n+        # If the current table is grouped then do the same in the copy\n+        if hasattr(self, '_groups'):\n+            out._groups = groups.TableGroups(out, \nindices=self._groups._indices,\n+                                             keys=self._groups._keys)\n+        return out\n+\n+    def __deepcopy__(self, memo=None):\n+        return self.copy(True)\n+\n+    def __copy__(self):\n+        return self.copy(False)\n+\n+    def __lt__(self, other):\n+        return super().__lt__(other)\n+\n+    def __gt__(self, other):\n+        return super().__gt__(other)\n+\n+    def __le__(self, other):\n+        return super().__le__(other)\n+\n+    def __ge__(self, other):\n+        return super().__ge__(other)\n+\n+    def __eq__(self, other):\n+        return self._rows_equal(other)\n+\n+    def __ne__(self, other):\n+        return ~self.__eq__(other)\n+\n+    def _rows_equal(self, other):\n+        \"\"\"\n+        Row-wise comparison of table with any other object.\n+\n+        This is actual implementation for __eq__.\n+\n+        Returns a 1-D boolean numpy array showing result of row-wise \ncomparison.\n+        This is the same as the ``==`` comparison for tables.\n+\n+        Parameters\n+        ----------\n+        other : Table or DataFrame or ndarray\n+             An object to compare with table\n+\n+        Examples\n+        --------\n+        Comparing one Table with other::\n+\n+            >>> t1 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))\n+            >>> t2 = Table([[1,2],[4,5],[7,8]], names=('a','b','c'))\n+            >>> t1._rows_equal(t2)\n+            array([ True,  True])\n+\n+        \"\"\"\n+\n+        if isinstance(other, Table):\n+            other = other.as_array()\n+\n+        if self.has_masked_columns:\n+            if isinstance(other, np.ma.MaskedArray):\n+                result = self.as_array() == other\n+            else:\n+                # If mask is True, then by definition the row doesn't match\n+                # because the other array is not masked.\n+                false_mask = np.zeros(1, dtype=[(n, bool) for n in \nself.dtype.names])\n+                result = (self.as_array().data == other) & (self.mask == \nfalse_mask)\n+        else:\n+            if isinstance(other, np.ma.MaskedArray):\n+                # If mask is True, then by definition the row doesn't match\n+                # because the other array is not masked.\n+                false_mask = np.zeros(1, dtype=[(n, bool) for n in \nother.dtype.names])\n+                result = (self.as_array() == other.data) & (other.mask == \nfalse_mask)\n+            else:\n+                result = self.as_array() == other\n+\n+        return result\n+\n+    def values_equal(self, other):\n+        \"\"\"\n+        Element-wise comparison of table with another table, list, or scalar.\n+\n+        Returns a ``Table`` with the same columns containing boolean values\n+        showing result of comparison.\n+\n+        Parameters\n+        ----------\n+        other : table-like object or list or scalar\n+             Object to compare with table\n+\n+        Examples\n+        --------\n+        Compare one Table with other::\n+\n+          >>> t1 = Table([[1, 2], [4, 5], [-7, 8]], names=('a', 'b', 'c'))\n+          >>> t2 = Table([[1, 2], [-4, 5], [7, 8]], names=('a', 'b', 'c'))\n+          >>> t1.values_equal(t2)\n+          <Table length=2>\n+           a     b     c\n+          bool  bool  bool\n+          ---- ----- -----\n+          True False False\n+          True  True  True\n+\n+        \"\"\"\n+        if isinstance(other, Table):\n+            names = other.colnames\n+        else:\n+            try:\n+                other = Table(other, copy=False)\n+                names = other.colnames\n+            except Exception:\n+                # Broadcast other into a dict, so e.g. other = 2 will turn into\n+                # other = {'a': 2, 'b': 2} and then equality does a\n+                # column-by-column broadcasting.\n+                names = self.colnames\n+                other = {name: other for name in names}\n+\n+        # Require column names match but do not require same column order\n+        if set(self.colnames) != set(names):\n+            raise ValueError('cannot compare tables with different column \nnames')\n+\n+        eqs = []\n+        for name in names:\n+            try:\n+                np.broadcast(self[name], other[name])  # Check if \nbroadcast-able\n+                # Catch the numpy FutureWarning related to equality checking,\n+                # \"elementwise comparison failed; returning scalar instead, but\n+                #  in the future will perform elementwise comparison\".  Turn \nthis\n+                # into an exception since the scalar answer is not what we \nwant.\n+                with warnings.catch_warnings(record=True) as warns:\n+                    warnings.simplefilter('always')\n+                    eq = self[name] == other[name]\n+                    if (warns and issubclass(warns[-1].category, FutureWarning)\n+                            and 'elementwise comparison failed' in \nstr(warns[-1].message)):\n+                        raise FutureWarning(warns[-1].message)\n+            except Exception as err:\n+                raise ValueError(f'unable to compare column {name}') from err\n+\n+            # Be strict about the result from the comparison. E.g. SkyCoord \n__eq__ is just\n+            # broken and completely ignores that it should return an array.\n+            if not (isinstance(eq, np.ndarray)\n+                    and eq.dtype is np.dtype('bool')\n+                    and len(eq) == len(self)):\n+                raise TypeError(f'comparison for column {name} returned {eq} '\n+                                f'instead of the expected boolean ndarray')\n+\n+            eqs.append(eq)\n+\n+        out = Table(eqs, names=names)\n+\n+        return out\n+\n+    @property\n+    def groups(self):\n+        if not hasattr(self, '_groups'):\n+            self._groups = groups.TableGroups(self)\n+        return self._groups\n+\n+    def group_by(self, keys):\n+        \"\"\"\n+        Group this table by the specified ``keys``\n+\n+        This effectively splits the table into groups which correspond to \nunique\n+        values of the ``keys`` grouping object.  The output is a new\n+        `~astropy.table.TableGroups` which contains a copy of this table but\n+        sorted by row according to ``keys``.\n+\n+        The ``keys`` input to `group_by` can be specified in different ways:\n+\n+          - String or list of strings corresponding to table column name(s)\n+          - Numpy array (homogeneous or structured) with same length as this \ntable\n+          - `~astropy.table.Table` with same length as this table\n+\n+        Parameters\n+        ----------\n+        keys : str, list of str, numpy array, or `~astropy.table.Table`\n+            Key grouping object\n+\n+        Returns\n+        -------\n+        out : `~astropy.table.Table`\n+            New table with groups set\n+        \"\"\"\n+        return groups.table_group_by(self, keys)\n+\n+    def to_pandas(self, index=None, use_nullable_int=True):\n+        \"\"\"\n+        Return a :class:`pandas.DataFrame` instance\n+\n+        The index of the created DataFrame is controlled by the ``index``\n+        argument.  For ``index=True`` or the default ``None``, an index will be\n+        specified for the DataFrame if there is a primary key index on the\n+        Table *and* if it corresponds to a single column.  If ``index=False``\n+        then no DataFrame index will be specified.  If ``index`` is the name of\n+        a column in the table then that will be the DataFrame index.\n+\n+        In addition to vanilla columns or masked columns, this supports Table\n+        mixin columns like Quantity, Time, or SkyCoord.  In many cases these\n+        objects have no analog in pandas and will be converted to a \"encoded\"\n+        representation using only Column or MaskedColumn.  The exception is\n+        Time or TimeDelta columns, which will be converted to the corresponding\n+        representation in pandas using ``np.datetime64`` or ``np.timedelta64``.\n+        See the example below.\n+\n+        Parameters\n+        ----------\n+        index : None, bool, str\n+            Specify DataFrame index mode\n+        use_nullable_int : bool, default=True\n+            Convert integer MaskedColumn to pandas nullable integer type.\n+            If ``use_nullable_int=False`` or the pandas version does not \nsupport\n+            nullable integer types (version < 0.24), then the column is \nconverted\n+            to float with NaN for missing elements and a warning is issued.\n+\n+        Returns\n+        -------\n+        dataframe : :class:`pandas.DataFrame`\n+            A pandas :class:`pandas.DataFrame` instance\n+\n+        Raises\n+        ------\n+        ImportError\n+            If pandas is not installed\n+        ValueError\n+            If the Table has multi-dimensional columns\n+\n+        Examples\n+        --------\n+        Here we convert a table with a few mixins to a\n+        :class:`pandas.DataFrame` instance.\n+\n+          >>> import pandas as pd\n+          >>> from astropy.table import QTable\n+          >>> import astropy.units as u\n+          >>> from astropy.time import Time, TimeDelta\n+          >>> from astropy.coordinates import SkyCoord\n+\n+          >>> q = [1, 2] * u.m\n+          >>> tm = Time([1998, 2002], format='jyear')\n+          >>> sc = SkyCoord([5, 6], [7, 8], unit='deg')\n+          >>> dt = TimeDelta([3, 200] * u.s)\n+\n+          >>> t = QTable([q, tm, sc, dt], names=['q', 'tm', 'sc', 'dt'])\n+\n+          >>> df = t.to_pandas(index='tm')\n+          >>> with pd.option_context('display.max_columns', 20):\n+          ...     print(df)\n+                        q  sc.ra  sc.dec              dt\n+          tm\n+          1998-01-01  1.0    5.0     7.0 0 days 00:00:03\n+          2002-01-01  2.0    6.0     8.0 0 days 00:03:20\n+\n+        \"\"\"\n+        from pandas import DataFrame, Series\n+\n+        if index is not False:\n+            if index in (None, True):\n+                # Default is to use the table primary key if available and a \nsingle column\n+                if self.primary_key and len(self.primary_key) == 1:\n+                    index = self.primary_key[0]\n+                else:\n+                    index = False\n+            else:\n+                if index not in self.colnames:\n+                    raise ValueError('index must be None, False, True or a \ntable '\n+                                     'column name')\n+\n+        def _encode_mixins(tbl):\n+            \"\"\"Encode a Table ``tbl`` that may have mixin columns to a Table \nwith only\n+            astropy Columns + appropriate meta-data to allow subsequent \ndecoding.\n+            \"\"\"\n+            from . import serialize\n+            from astropy.time import TimeBase, TimeDelta\n+\n+            # Convert any Time or TimeDelta columns and pay attention to \nmasking\n+            time_cols = [col for col in tbl.itercols() if isinstance(col, \nTimeBase)]\n+            if time_cols:\n+\n+                # Make a light copy of table and clear any indices\n+                new_cols = []\n+                for col in tbl.itercols():\n+                    new_col = col_copy(col, copy_indices=False) if \ncol.info.indices else col\n+                    new_cols.append(new_col)\n+                tbl = tbl.__class__(new_cols, copy=False)\n+\n+                # Certain subclasses (e.g. TimeSeries) may generate new indices\non\n+                # table creation, so make sure there are no indices on the \ntable.\n+                for col in tbl.itercols():\n+                    col.info.indices.clear()\n+\n+                for col in time_cols:\n+                    if isinstance(col, TimeDelta):\n+                        # Convert to nanoseconds (matches astropy datetime64 \nsupport)\n+                        new_col = (col.sec * 1e9).astype('timedelta64[ns]')\n+                        nat = np.timedelta64('NaT')\n+                    else:\n+                        new_col = col.datetime64.copy()\n+                        nat = np.datetime64('NaT')\n+                    if col.masked:\n+                        new_col[col.mask] = nat\n+                    tbl[col.info.name] = new_col\n+\n+            # Convert the table to one with no mixins, only Column objects.\n+            encode_tbl = serialize.represent_mixins_as_columns(tbl)\n+            return encode_tbl\n+\n+        tbl = _encode_mixins(self)\n+\n+        badcols = [name for name, col in self.columns.items() if len(col.shape)\n> 1]\n+        if badcols:\n+            raise ValueError(\n+                f'Cannot convert a table with multidimensional columns to a '\n+                f'pandas DataFrame. Offending columns are: {badcols}\\n'\n+                f'One can filter out such columns using:\\n'\n+                f'names = [name for name in tbl.colnames if \nlen(tbl[name].shape) <= 1]\\n'\n+                f'tbl[names].to_pandas(...)')\n+\n+        out = OrderedDict()\n+\n+        for name, column in tbl.columns.items():\n+            if getattr(column.dtype, 'isnative', True):\n+                out[name] = column\n+            else:\n+                out[name] = column.data.byteswap().newbyteorder('=')\n+\n+            if isinstance(column, MaskedColumn) and np.any(column.mask):\n+                if column.dtype.kind in ['i', 'u']:\n+                    pd_dtype = column.dtype.name\n+                    if use_nullable_int:\n+                        # Convert int64 to Int64, uint32 to UInt32, etc for \nnullable types\n+                        pd_dtype = pd_dtype.replace('i', 'I').replace('u', 'U')\n+                    out[name] = Series(out[name], dtype=pd_dtype)\n+\n+                    # If pandas is older than 0.24 the type may have turned to \nfloat\n+                    if column.dtype.kind != out[name].dtype.kind:\n+                        warnings.warn(\n+                            f\"converted column '{name}' from {column.dtype} to \n{out[name].dtype}\",\n+                            TableReplaceWarning, stacklevel=3)\n+                elif column.dtype.kind not in ['f', 'c']:\n+                    out[name] = column.astype(object).filled(np.nan)\n+\n+        kwargs = {}\n+\n+        if index:\n+            idx = out.pop(index)\n+\n+            kwargs['index'] = idx\n+\n+            # We add the table index to Series inputs (MaskedColumn with int \nvalues) to override\n+            # its default RangeIndex, see #11432\n+            for v in out.values():\n+                if isinstance(v, Series):\n+                    v.index = idx\n+\n+        df = DataFrame(out, **kwargs)\n+        if index:\n+            # Explicitly set the pandas DataFrame index to the original table\n+            # index name.\n+            df.index.name = idx.info.name\n+\n+        return df\n+\n+    @classmethod\n+    def from_pandas(cls, dataframe, index=False, units=None):\n+        \"\"\"\n+        Create a `~astropy.table.Table` from a :class:`pandas.DataFrame` \ninstance\n+\n+        In addition to converting generic numeric or string columns, this \nsupports\n+        conversion of pandas Date and Time delta columns to \n`~astropy.time.Time`\n+        and `~astropy.time.TimeDelta` columns, respectively.\n+\n+        Parameters\n+        ----------\n+        dataframe : :class:`pandas.DataFrame`\n+            A pandas :class:`pandas.DataFrame` instance\n+        index : bool\n+            Include the index column in the returned table (default=False)\n+        units: dict\n+            A dict mapping column names to to a `~astropy.units.Unit`.\n+            The columns will have the specified unit in the Table.\n+\n+        Returns\n+        -------\n+        table : `~astropy.table.Table`\n+            A `~astropy.table.Table` (or subclass) instance\n+\n+        Raises\n+        ------\n+        ImportError\n+            If pandas is not installed\n+\n+        Examples\n+        --------\n+        Here we convert a :class:`pandas.DataFrame` instance\n+        to a `~astropy.table.QTable`.\n+\n+          >>> import numpy as np\n+          >>> import pandas as pd\n+          >>> from astropy.table import QTable\n+\n+          >>> time = pd.Series(['1998-01-01', '2002-01-01'], \ndtype='datetime64[ns]')\n+          >>> dt = pd.Series(np.array([1, 300], dtype='timedelta64[s]'))\n+          >>> df = pd.DataFrame({'time': time})\n+          >>> df['dt'] = dt\n+          >>> df['x'] = [3., 4.]\n+          >>> with pd.option_context('display.max_columns', 20):\n+          ...     print(df)\n+                  time              dt    x\n+          0 1998-01-01 0 days 00:00:01  3.0\n+          1 2002-01-01 0 days 00:05:00  4.0\n+\n+          >>> QTable.from_pandas(df)\n+          <QTable length=2>\n+                    time              dt       x\n+                    Time          TimeDelta float64\n+          ----------------------- --------- -------\n+          1998-01-01T00:00:00.000       1.0     3.0\n+          2002-01-01T00:00:00.000     300.0     4.0\n+\n+        \"\"\"\n+\n+        out = OrderedDict()\n+\n+        names = list(dataframe.columns)\n+        columns = [dataframe[name] for name in names]\n+        datas = [np.array(column) for column in columns]\n+        masks = [np.array(column.isnull()) for column in columns]\n+\n+        if index:\n+            index_name = dataframe.index.name or 'index'\n+            while index_name in names:\n+                index_name = '_' + index_name + '_'\n+            names.insert(0, index_name)\n+            columns.insert(0, dataframe.index)\n+            datas.insert(0, np.array(dataframe.index))\n+            masks.insert(0, np.zeros(len(dataframe), dtype=bool))\n+\n+        if units is None:\n+            units = [None] * len(names)\n+        else:\n+            if not isinstance(units, Mapping):\n+                raise TypeError('Expected a Mapping \"column-name\" -> \"unit\"')\n+\n+            not_found = set(units.keys()) - set(names)\n+            if not_found:\n+                warnings.warn(f'`units` contains additional columns: \n{not_found}')\n+\n+            units = [units.get(name) for name in names]\n+\n+        for name, column, data, mask, unit in zip(names, columns, datas, masks,\nunits):\n+\n+            if column.dtype.kind in ['u', 'i'] and np.any(mask):\n+                # Special-case support for pandas nullable int\n+                np_dtype = str(column.dtype).lower()\n+                data = np.zeros(shape=column.shape, dtype=np_dtype)\n+                data[~mask] = column[~mask]\n+                out[name] = MaskedColumn(data=data, name=name, mask=mask, \nunit=unit, copy=False)\n+                continue\n+\n+            if data.dtype.kind == 'O':\n+                # If all elements of an object array are string-like or np.nan\n+                # then coerce back to a native numpy str/unicode array.\n+                string_types = (str, bytes)\n+                nan = np.nan\n+                if all(isinstance(x, string_types) or x is nan for x in data):\n+                    # Force any missing (null) values to b''.  Numpy will\n+                    # upcast to str/unicode as needed.\n+                    data[mask] = b''\n+\n+                    # When the numpy object array is represented as a list then\n+                    # numpy initializes to the correct string or unicode type.\n+                    data = np.array([x for x in data])\n+\n+            # Numpy datetime64\n+            if data.dtype.kind == 'M':\n+                from astropy.time import Time\n+                out[name] = Time(data, format='datetime64')\n+                if np.any(mask):\n+                    out[name][mask] = np.ma.masked\n+                out[name].format = 'isot'\n+\n+            # Numpy timedelta64\n+            elif data.dtype.kind == 'm':\n+                from astropy.time import TimeDelta\n+                data_sec = data.astype('timedelta64[ns]').astype(np.float64) / \n1e9\n+                out[name] = TimeDelta(data_sec, format='sec')\n+                if np.any(mask):\n+                    out[name][mask] = np.ma.masked\n+\n+            else:\n+                if np.any(mask):\n+                    out[name] = MaskedColumn(data=data, name=name, mask=mask, \nunit=unit)\n+                else:\n+                    out[name] = Column(data=data, name=name, unit=unit)\n+\n+        return cls(out)\n+\n+    info = TableInfo()\n+\n+\n+class QTable(Table):\n+    \"\"\"A class to represent tables of heterogeneous data.\n+\n+    `~astropy.table.QTable` provides a class for heterogeneous tabular data\n+    which can be easily modified, for instance adding columns or new rows.\n+\n+    The `~astropy.table.QTable` class is identical to `~astropy.table.Table`\n+    except that columns with an associated ``unit`` attribute are converted to\n+    `~astropy.units.Quantity` objects.\n+\n+    See also:\n+\n+    - https://docs.astropy.org/en/stable/table/\n+    - https://docs.astropy.org/en/stable/table/mixin_columns.html\n+\n+    Parameters\n+    ----------\n+    data : numpy ndarray, dict, list, table-like object, optional\n+        Data to initialize table.\n+    masked : bool, optional\n+        Specify whether the table is masked.\n+    names : list, optional\n+        Specify column names.\n+    dtype : list, optional\n+        Specify column data types.\n+    meta : dict, optional\n+        Metadata associated with the table.\n+    copy : bool, optional\n+        Copy the input data. Default is True.\n+    rows : numpy ndarray, list of list, optional\n+        Row-oriented data for table instead of ``data`` argument.\n+    copy_indices : bool, optional\n+        Copy any indices in the input data. Default is True.\n+    **kwargs : dict, optional\n+        Additional keyword args when converting table-like object.\n+\n+    \"\"\"\n+\n+    def _is_mixin_for_table(self, col):\n+        \"\"\"\n+        Determine if ``col`` should be added to the table directly as\n+        a mixin column.\n+        \"\"\"\n+        return has_info_class(col, MixinInfo)\n+\n+    def _convert_col_for_table(self, col):\n+        if isinstance(col, Column) and getattr(col, 'unit', None) is not None:\n+            # We need to turn the column into a quantity; use subok=True to \nallow\n+            # Quantity subclasses identified in the unit (such as u.mag()).\n+            q_cls = Masked(Quantity) if isinstance(col, MaskedColumn) else \nQuantity\n+            try:\n+                qcol = q_cls(col.data, col.unit, copy=False, subok=True)\n+            except Exception as exc:\n+                warnings.warn(f\"column {col.info.name} has a unit but is kept \nas \"\n+                              f\"a {col.__class__.__name__} as an attempt to \"\n+                              f\"convert it to Quantity failed with:\\n{exc!r}\",\n+                              AstropyUserWarning)\n+            else:\n+                qcol.info = col.info\n+                qcol.info.indices = col.info.indices\n+                col = qcol\n+        else:\n+            col = super()._convert_col_for_table(col)\n+\n+        return col\n\nSaved trajectory to '/results/20260128_192624/astropy__astropy-13236/astropy__astropy-13236.traj.json'\n\ud83e\udd96 DEBUG    Ensuring deployment is stopped because object is deleted            \n",
  "stderr": "Warning: Input is not a terminal (fd=0).\n/usr/local/lib/python3.12/site-packages/click/core.py:1223: UserWarning: The parameter -c is used more than once. Remove its duplicate as parameters should be unique.\n  parser = self.make_parser(ctx)\n/usr/local/lib/python3.12/site-packages/click/core.py:1216: UserWarning: The parameter -c is used more than once. Remove its duplicate as parameters should be unique.\n  self.parse_args(ctx, args)\n\nGenerating test split:   0%|          | 0/500 [00:00<?, ? examples/s]\nGenerating test split: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 500/500 [00:00<00:00, 15264.45 examples/s]\n",
  "end_time": "2026-01-28T11:28:24.153138",
  "duration_seconds": 107.327653
}